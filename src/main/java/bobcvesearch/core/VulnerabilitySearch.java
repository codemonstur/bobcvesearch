package bobcvesearch.core;

import bobcvesearch.model.CliCveSearch;
import bobcvesearch.model.Finding;
import bobcvesearch.model.SuppressRule;
import bobthebuildtool.pojos.buildfile.Dependency;
import bobthebuildtool.pojos.buildfile.Project;
import bobthebuildtool.pojos.error.DependencyResolutionFailed;
import org.apache.lucene.document.Document;
import org.apache.lucene.index.Term;
import org.apache.lucene.search.*;

import java.io.IOException;
import java.util.*;

import static bobcvesearch.core.DependencyResolution.listProjectDependencies;
import static bobcvesearch.core.GavToCPE.toCPEs;
import static bobcvesearch.core.GavToCPE.toCoordinate;
import static bobcvesearch.core.NistVulnerabilityDatabase.updateNistVulnerabilityDatabase;
import static bobcvesearch.core.SearchIndex.newIndexSearcher;
import static bobcvesearch.model.SuppressionsFile.loadSuppresionsFile;
import static bobthebuildtool.services.Functions.isNullOrEmpty;
import static java.lang.Integer.MAX_VALUE;
import static java.util.stream.Collectors.toList;
import static org.apache.lucene.search.BooleanClause.Occur.SHOULD;

public enum VulnerabilitySearch {;

    public static List<Finding> findVulnerabilities(final Project project, final CliCveSearch cli, final List<String> dbNames)
            throws IOException, DependencyResolutionFailed {
        updateNistVulnerabilityDatabase(cli.numDays, dbNames);

        final var file = loadSuppresionsFile(project, cli.suppressions);
        return removeSuppressed(findVulnerabilities(listProjectDependencies(project), dbNames), file.rules);
    }

    private static List<Finding> findVulnerabilities(final List<Dependency> dependencies, final List<String> dbNames) throws IOException {
        final var knownCpeMap = GavToCPE.loadCoordinateToCpe();

        final var findings = new ArrayList<Finding>();
        for (final var dependency : dependencies) {
            findings.addAll(findMatchingDocuments(dependency, dbNames, knownCpeMap));
        }

        return findings;
    }

    private static Set<Finding> findMatchingDocuments(final Dependency dependency
            , final List<String> dbNames, final Map<String, List<String>> knownCpeMap) throws IOException {
        final var findings = new HashSet<Finding>();

        final var coordinate = toCoordinate(dependency, null);
        if (coordinate != null) {
            for (final var name : dbNames) {
                final var searcher = newIndexSearcher(name);

                for (final var query : newQueries(dependency, coordinate, knownCpeMap)) {
                    final var results = searcher.search(query, MAX_VALUE);
                    findings.addAll(toFindings(coordinate, searcher, results));
                }
            }
        }

        return findings;
    }

    private static List<Query> newQueries(final Dependency dependency, final String coordinate
            , final Map<String, List<String>> knownCpeMap) {
        final var queries = new ArrayList<Query>();

        List<String> cpes = knownCpeMap.get(coordinate);
        if (isNullOrEmpty(cpes)) cpes = toCPEs(dependency);
        for (final var cpe : cpes) {
            queries.add(new WildcardQuery(new Term("cpe", cpe)));
        }

        final var builder = new BooleanQuery.Builder();
        for (final var word : coordinate.split(":")) {
            builder.add(new TermQuery(new Term("description", word)), SHOULD);
        }
        queries.add(builder.build());

        return queries;
    }

    private static Collection<Finding> toFindings(final String coordinate, final IndexSearcher searcher,
                                                  final TopDocs results) throws IOException {
        final var list = new ArrayList<Finding>(results.scoreDocs.length);
        for (final var hit : results.scoreDocs) {
            list.add(newFinding(coordinate, hit, searcher.doc(hit.doc)));
        }
        return list;
    }

    private static Finding newFinding(final String coordinate, final ScoreDoc hit, final Document document) {
        return new Finding(coordinate, document.get("cve"), hit.score, document.get("cvssV2"), document.get("cvssV3"));
    }

    private static List<Finding> removeSuppressed(final List<Finding> findings, final Set<SuppressRule> suppressions) {
        return findings.stream()
            .filter(finding -> !suppressions.contains(new SuppressRule(finding.cve, finding.coordinate)))
            .collect(toList());
    }

}
