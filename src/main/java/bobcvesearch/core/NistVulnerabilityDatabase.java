package bobcvesearch.core;

import bobcvesearch.model.Finding;
import bobcvesearch.model.NvdMetaData;
import bobcvesearch.model.NvdModel;
import bobcvesearch.model.NvdModel.CveItem;
import bobthebuildtool.pojos.buildfile.Dependency;
import org.apache.lucene.analysis.standard.StandardAnalyzer;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.StringField;
import org.apache.lucene.document.TextField;
import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexWriter;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.index.Term;
import org.apache.lucene.search.*;
import org.apache.lucene.store.MMapDirectory;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URI;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.zip.GZIPInputStream;

import static bobthebuildtool.services.Constants.HTTP_CLIENT;
import static bobthebuildtool.services.Constants.JSON_PARSER;
import static bobthebuildtool.services.Functions.isNullOrEmpty;
import static java.lang.Integer.MAX_VALUE;
import static java.lang.System.currentTimeMillis;
import static java.net.http.HttpResponse.BodyHandlers.ofFile;
import static java.net.http.HttpResponse.BodyHandlers.ofString;
import static java.nio.file.Files.*;
import static java.time.format.DateTimeFormatter.ISO_INSTANT;
import static java.util.concurrent.TimeUnit.DAYS;
import static org.apache.lucene.document.Field.Store.YES;
import static org.apache.lucene.search.BooleanClause.Occur.SHOULD;

public enum NistVulnerabilityDatabase {;

    private static final String
        DB_LOCATION = ".bob/security/cve",
        NVD_META_URI = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-%s.meta",
        NVD_DATA_URI = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-%s.json.gz";

    private static final List<String> NVD_DB_NAMES = List.of("modified", "recent", "2021", "2020",
            "2019", "2018", "2017", "2016", "2015", "2014", "2013", "2012", "2011", "2010", "2009",
            "2008", "2007", "2006", "2005", "2004", "2003", "2002");

    public static void updateNistVulnerabilityDatabase(final long numDaysBetweenUpdates) throws IOException {
        for (final var name : NVD_DB_NAMES) {
            updateDatabaseWithName(numDaysBetweenUpdates, name);
        }
    }

    private static void updateDatabaseWithName(final long numDaysAgo, final String name) throws IOException {
        final NvdMetaData storedMeta = loadMetaDataFromFile(name);
        if (!mustUpdate(storedMeta, numDaysAgo)) return;

        final NvdMetaData newMeta = saveMetaData(name, downloadMetaData(name));
        if (!mustDownload(storedMeta, newMeta)) return;

        try (final IndexWriter index = newSearchIndexWriter(name)) {
            recreateIndex(index, downloadNewDatabaseEntries(name));
        }
    }

    private static NvdMetaData loadMetaDataFromFile(final String name) throws IOException {
        final var path = metaNameToPath(name);
        return !isRegularFile(path) ? null : JSON_PARSER.fromJson(readString(path), NvdMetaData.class);
    }

    public static NvdMetaData downloadMetaData(final String name) throws IOException {
        final var location = newNvdUri(NVD_META_URI, name);
        try {
            final var request = HttpRequest.newBuilder().uri(location).GET().build();
            final var response = requireResponseCode(HTTP_CLIENT.send(request, ofString()), 200);

            return new NvdMetaData(currentTimeMillis(), metaDataToTimestamp(response.body()));
        } catch (InterruptedException e) {
            throw new IOException("Interrupted during NVD metadata download for URL " + location, e);
        } catch (NoSuchElementException e) {
            throw new IOException("NVD metadata for URL " + location + " does not contain a 'lastModifiedDate' line");
        }
    }

    public static long metaDataToTimestamp(final String metadata) {
        return Arrays.stream(metadata.split("\n"))
            .filter(line -> line.startsWith("lastModifiedDate:"))
            .map(dateLine -> dateLine.substring(dateLine.indexOf(':')+1).trim())
            .map(date -> Instant.from(ISO_INSTANT.parse(date)).toEpochMilli())
            .findFirst().get();
    }

    private static NvdMetaData saveMetaData(final String name, final NvdMetaData meta) throws IOException {
        final Path path = metaNameToPath(name);
        createDirectories(path.getParent());
        writeString(path, JSON_PARSER.toJson(meta));
        return meta;
    }

    private static boolean mustUpdate(final NvdMetaData meta, final long numDays) {
        return meta == null || meta.lastCheckedDate < currentTimeMillis() - DAYS.toMillis(numDays);
    }
    private static boolean mustDownload(final NvdMetaData storedMeta, final NvdMetaData newMeta) {
        return storedMeta == null || newMeta.lastModifiedDate > storedMeta.lastModifiedDate;
    }

    private static Path metaNameToPath(final String name) {
        return Paths.get(System.getProperty("user.dir"), DB_LOCATION, "meta", name+".json");
    }

    private static NvdModel downloadNewDatabaseEntries(final String name) throws IOException {
        final var location = newNvdUri(NVD_DATA_URI, name);

        final var tempFile = createTempFile("nvd_", ".tmp.gz");
        try {
            final var request = HttpRequest.newBuilder().uri(location).GET().build();
            requireResponseCode(HTTP_CLIENT.send(request, ofFile(tempFile)), 200);
            try (final var file = new InputStreamReader(new GZIPInputStream(new FileInputStream(tempFile.toFile())))) {
                return JSON_PARSER.fromJson(file, NvdModel.class);
            }
        } catch (InterruptedException e) {
            throw new IOException("Interrupted during NVD metadata download for URL " + location, e);
        } finally {
            Files.delete(tempFile);
        }
    }

    private static IndexWriter newSearchIndexWriter(final String name) throws IOException {
        final var pathToIndex = Files.createDirectories(Paths.get(DB_LOCATION, "index", name));
        return new IndexWriter(new MMapDirectory(pathToIndex), new IndexWriterConfig(new StandardAnalyzer()));
    }

    private static void recreateIndex(final IndexWriter index, final NvdModel data) throws IOException {
        index.deleteAll();
        for (final var cve : data.CVE_Items) {
            index.addDocument(newCveDocument(cve));
        }
    }

    private static Document newCveDocument(final CveItem cve){
        final Document document = new Document();
        document.add(new StringField("cve", cve.getID(), YES));
        document.add(new StringField("cpe", cve.getCPEs(), YES));
        document.add(new StringField("cvssV2", cve.getCvssV2(), YES));
        document.add(new StringField("cvssV3", cve.getCvssV3(), YES));
        document.add(new TextField("description", cve.getDescription(), YES));
        return document;
    }

    private static URI newNvdUri(final String template, final String name) {
        return URI.create(String.format(template, name));
    }

    private static IndexSearcher newIndexSearcher(final String name) throws IOException {
        final var pathToIndex = Files.createDirectories(Paths.get(DB_LOCATION, "index", name));
        return new IndexSearcher(DirectoryReader.open(new MMapDirectory(pathToIndex)));
    }

    public static List<Finding> findMatchingDocuments(final Dependency dependency) throws IOException {
        final var list = new ArrayList<Finding>();

        final var query = toQuery(dependency);
        for (final var name : NVD_DB_NAMES) {
            final var searcher = newIndexSearcher(name);
            for (final var hit : searcher.search(query, MAX_VALUE).scoreDocs) {
                final var document = searcher.doc(hit.doc);
                list.add(newFinding(dependency, hit, document));
            }
        }

        return list;
    }

    private static Query toQuery(final Dependency dependency) {
        final var builder = new BooleanQuery.Builder();
        toSearchTerms(dependency).forEach(s -> {
            builder.add(new TermQuery(new Term("cpe", s)), SHOULD);
            builder.add(new TermQuery(new Term("description", s)), SHOULD);
        });
        return builder.build();
    }

    private static List<String> toSearchTerms(Dependency dependency) {
        final var list = new ArrayList<String>();
        if (!isNullOrEmpty(dependency.github)) {
            list.addAll(Arrays.asList(dependency.github.split(":")));
        }
        if (!isNullOrEmpty(dependency.repository)) {
            list.addAll(Arrays.asList(dependency.repository.split(":")));
        }
        return list;
    }

    public static Finding newFinding(final Dependency dependency, final ScoreDoc hit, final Document document) {
        return new Finding(dependency, hit.score, document.get("cve"), document.get("cvssV2"), document.get("cvssV3"));
    }

    private static <T> HttpResponse<T> requireResponseCode(final HttpResponse<T> response, final int code) throws IOException {
        if (response.statusCode() != code)
            throw new IOException(response.request().uri() + " returned invalid status code " + response.statusCode());
        return response;
    }

}
