package bobcvesearch.core;

import bobcvesearch.model.NvdMetaData;
import bobcvesearch.model.NvdModel;
import org.apache.lucene.index.IndexWriter;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.URI;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.zip.GZIPInputStream;

import static bobcvesearch.BobPlugin.DB_LOCATION;
import static bobcvesearch.core.SearchIndex.newIndexWriter;
import static bobcvesearch.core.SearchIndex.recreateIndex;
import static bobthebuildtool.services.Constants.HTTP_CLIENT;
import static bobthebuildtool.services.Constants.JSON_PARSER;
import static java.lang.System.currentTimeMillis;
import static java.net.http.HttpResponse.BodyHandlers.ofFile;
import static java.net.http.HttpResponse.BodyHandlers.ofString;
import static java.nio.file.Files.*;
import static java.time.format.DateTimeFormatter.ISO_INSTANT;
import static java.util.concurrent.TimeUnit.DAYS;

public enum NistVulnerabilityDatabase {;

    private static final String
        NVD_META_URI = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-%s.meta",
        NVD_DATA_URI = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-%s.json.gz";

    public static void updateNistVulnerabilityDatabase(final long numDaysBetweenUpdates, final List<String> dbNames) throws IOException {
        for (final var name : dbNames) {
            updateDatabaseWithName(numDaysBetweenUpdates, name);
        }
    }

    private static void updateDatabaseWithName(final long numDaysAgo, final String name) throws IOException {
        final NvdMetaData storedMeta = loadMetaDataFromFile(name);
        if (!mustUpdate(storedMeta, numDaysAgo)) return;

        final NvdMetaData newMeta = saveMetaData(name, downloadMetaData(name));
        if (!mustDownload(storedMeta, newMeta)) return;

        try (final IndexWriter index = newIndexWriter(name)) {
            recreateIndex(index, downloadNewDatabaseEntries(name));
        }
    }

    private static NvdMetaData loadMetaDataFromFile(final String name) throws IOException {
        final var path = metaNameToPath(name);
        return !isRegularFile(path) ? null : JSON_PARSER.fromJson(readString(path), NvdMetaData.class);
    }

    private static NvdMetaData downloadMetaData(final String name) throws IOException {
        final var location = newNvdUri(NVD_META_URI, name);
        try {
            final var request = HttpRequest.newBuilder().uri(location).GET().build();
            final var response = requireResponseCode(HTTP_CLIENT.send(request, ofString()), 200);

            return new NvdMetaData(currentTimeMillis(), metaDataToTimestamp(response.body()));
        } catch (InterruptedException e) {
            throw new IOException("Interrupted during NVD metadata download for URL " + location, e);
        } catch (NoSuchElementException e) {
            throw new IOException("NVD metadata for URL " + location + " does not contain a 'lastModifiedDate' line");
        }
    }

    private static long metaDataToTimestamp(final String metadata) {
        return Arrays.stream(metadata.split("\n"))
            .filter(line -> line.startsWith("lastModifiedDate:"))
            .map(dateLine -> dateLine.substring(dateLine.indexOf(':')+1).trim())
            .map(date -> Instant.from(ISO_INSTANT.parse(date)).toEpochMilli())
            .findFirst().get();
    }

    private static NvdMetaData saveMetaData(final String name, final NvdMetaData meta) throws IOException {
        final Path path = metaNameToPath(name);
        createDirectories(path.getParent());
        writeString(path, JSON_PARSER.toJson(meta));
        return meta;
    }

    private static boolean mustUpdate(final NvdMetaData meta, final long numDays) {
        return meta == null || meta.lastCheckedDate < currentTimeMillis() - DAYS.toMillis(numDays);
    }
    private static boolean mustDownload(final NvdMetaData storedMeta, final NvdMetaData newMeta) {
        return storedMeta == null || newMeta.lastModifiedDate > storedMeta.lastModifiedDate;
    }

    private static Path metaNameToPath(final String name) {
        return Paths.get(System.getProperty("user.dir"), DB_LOCATION, "meta", name+".json");
    }

    private static NvdModel downloadNewDatabaseEntries(final String name) throws IOException {
        final var location = newNvdUri(NVD_DATA_URI, name);

        final var tempFile = createTempFile("nvd_", ".tmp.gz");
        try {
            final var request = HttpRequest.newBuilder().uri(location).GET().build();
            requireResponseCode(HTTP_CLIENT.send(request, ofFile(tempFile)), 200);
            try (final var file = new InputStreamReader(new GZIPInputStream(new FileInputStream(tempFile.toFile())))) {
                return JSON_PARSER.fromJson(file, NvdModel.class);
            }
        } catch (InterruptedException e) {
            throw new IOException("Interrupted during NVD metadata download for URL " + location, e);
        } finally {
            Files.delete(tempFile);
        }
    }

    private static URI newNvdUri(final String template, final String name) {
        return URI.create(String.format(template, name));
    }

    private static <T> HttpResponse<T> requireResponseCode(final HttpResponse<T> response, final int code) throws IOException {
        if (response.statusCode() != code)
            throw new IOException(response.request().uri() + " returned invalid status code " + response.statusCode());
        return response;
    }

}
